Abstract Class vs Interface in C#
When learning about interfaces and how they can be used to achieve something 
similar to multiple inheritance in C#, a common question arises: 
"When should I use an abstract class and when should I use an interface?"

Both abstract classes and interfaces allow you to define contracts for your classes, 
but they serve different purposes, and understanding those differences will make your architecture cleaner and more maintainable.

1. What is an Abstract Class?
    An abstract class is a class that cannot be instantiated on its own. It exists to be inherited from by other classes.
    It can contain:
    Abstract members (methods or properties without implementation) — these must be implemented by derived classes.
    Concrete members (fully implemented methods or properties) — these can be inherited and reused by derived classes.
    Fields and constructors — like any normal class.
    Think of an abstract class as a partially built template: some functionality is ready to use, and some is left for subclasses to define.
    Example:

    public abstract class PrinterBase {
        public abstract void Print(string document); // must be implemented
    
        public virtual void PowerOn() {
            Console.WriteLine("Powering on...");
        }
    }


2. What is an Interface?
    An interface is a pure contract — it defines what a class must do, but not how it does it.
    It can contain:
    Method signatures
    Property signatures
    Event declarations
    Indexers
    It cannot contain:
    Fields
    Constructors
    Implementations (before C# 8 — with C# 8+, default interface methods exist, but this is generally avoided in basic design for clarity)
    A class or struct that implements an interface must provide an implementation for all of its members.
    Example:
    public interface IPrintable{
        void Print(string document);
    }
    
    public interface IScannable{
        void Scan();
    }


3. Key Differences Between Abstract Class and Interface
    FeatureAbstract ClassInterfacePurposeDefines a base template with shared functionality and 
    enforces certain methods to be implemented.Defines a contract only — “what” to do, not “how.”
    ImplementationCan have both abstract (unimplemented) and concrete (implemented) members.
    Traditionally no implementations (until C# 8's default methods, which are rarely used in basic OOP).
    Fields and StateCan have fields, properties with backing fields, and maintain state.
    Cannot have instance fields or maintain state.ConstructorsCan define constructors to enforce initialization logic.
    No constructors allowed.InheritanceA class can inherit from only one abstract (or any) class.
    A class can implement multiple interfaces.Access ModifiersMembers can have different access 
    levels (public, protected, etc.).All members are public by default.
    VersioningChanging an abstract class is less risky because derived classes only break if abstract members change.
    Changing an interface by adding members breaks all implementing types unless they also add the new members.


4. When to Use an Abstract Class
    Use an abstract class when:
        You have common functionality that multiple derived classes should share.
        You want to provide default behavior for some members but require others to be overridden.
        You expect the base type to evolve over time without breaking many implementations.
        You want to maintain shared state across derived classes.
        Example scenario:
        A PrinterBase class that has a common PowerOn() method and shared status-tracking fields, 
        but requires each specific printer model to implement its own Print() method.

5. When to Use an Interface
    Use an interface when:
        You only care about the capabilities of a class, not its inheritance hierarchy.
        You need multiple inheritance of behavior contracts (since C# classes can’t inherit from more than one base class).
        You want maximum flexibility and decoupling between components.
        You’re defining a plugin or service API where the actual implementation may vary widely.
        Example scenario:
        A MultiFunctionPrinter might implement both IPrintable and IScannable. 
        This allows it to be treated as either a printer, a scanner, or both — depending on 
        context — without forcing unrelated devices into the same inheritance chain.